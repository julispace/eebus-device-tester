<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <title>EEBUS Device Tester</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
        :root {
            --bg: #f6f8fa;
            --card: #ffffff;
            --muted: #6b7280;
            --accent: #2563eb;
            --success: #059669;
            --danger: #ef4444;
            --code-bg: #111;
            --code-color: #bada55;
        }

        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            font-family: Inter, Roboto, Arial, sans-serif;
            color: #111
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 12px;
            padding: 12px;
            box-sizing: border-box;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        .top {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            height: calc(100vh - 260px);
        }

        .card {
            background: var(--card);
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(16, 24, 40, 0.03);
            padding: 12px;
        }

        /* draggable splitter between left and right columns */
        .splitter {
            width: 8px;
            cursor: col-resize;
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.06), transparent);
            border-radius: 4px;
            align-self: stretch;
        }

        .splitter:hover {
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.12), transparent);
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        /* left column (small) */
        #leftColumn { /* much smaller to give parsed traces priority */
            width: 300px;
            min-width: 240px;
            max-width: 420px;
            box-sizing: border-box;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* control panel: labels above inputs */
        .field-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px
        }

        label {
            color: var(--muted);
            font-size: 13px
        }

        input[type="text"], input[type="number"], select {
            padding: 6px 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer
        }

        button.secondary {
            background: #e5e7eb;
            color: #111
        }

        /* usecases */
        #usecaseList {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .usecase {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #fbfdff;
            border-radius: 6px;
            border: 1px solid #f1f5f9
        }

        .usecase .state.supported {
            color: var(--success);
            font-weight: 600
        }

        .usecase .state.unsupported {
            color: var(--muted)
        }

        /* right column */
        /* SPINE Messages & Trace Log tabs */
        #parsedTracesList {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 280px; /* roughly 10 items x ~28px */
            overflow: auto;
        }

        #parsedTracesList li {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 6px;
            display: flex;
            gap: 8px;
            align-items: center;
            cursor: pointer;
            background: #fff;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.02) inset;
            font-size: 13px;
            line-height: 18px;
        }

        .trace-meta {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 13px;
            color: #111
        }

        .trace-ts {
            color: var(--muted);
            width: 150px
        }

        .dir-recv {
            color: var(--accent);
            font-weight: 700
        }

        .dir-send {
            color: purple;
            font-weight: 700
        }

        /* entities tree */
        #entitiesPanel {
            margin-bottom: 10px;
        }

        #entitiesList {
            list-style: none;
            padding: 0;
            margin: 0;
            border: 1px solid #eef2ff;
            border-radius: 6px;
            /* show all entries, no internal scroll */
        }

        #entitiesList li {
            padding: 8px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer
        }

        #entitiesList li .sub {
            margin-left: 12px;
            font-size: 13px;
            color: #333
        }

        .tree-toggle {
            display: inline-block;
            width: 18px;
            text-align: center;
            color: var(--muted)
        }

        .entity-addr {
            font-weight: 600
        }

        /* detail panel */
        #traceDetailPanel {
            position: relative;
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #traceDetail {
            display: none;
            white-space: pre-wrap;
            background: #0b1220;
            color: #dbeafe;
            padding: 12px;
            border-radius: 6px;
            overflow: auto;
            flex: 1;
            max-height: 360px;
        }

        #traceDetail.header {
            display: flex;
        }

        #traceDetailClose {
            position: absolute;
            right: 8px;
            top: 8px;
            background: transparent;
            border: 0;
            color: #fff;
            cursor: pointer
        }

        /* logs bottom */
        footer .card {
            padding: 8px
        }

        #logs {
            white-space: pre-wrap;
            background: var(--code-bg);
            color: var(--code-color);
            padding: 10px;
            height: 180px;
            overflow: auto;
            border-radius: 6px
        }

        /* responsive */
        @media (max-width: 900px) {
            .top {
                grid-template-columns: 1fr;
            }

            #parsedTracesList {
                max-height: 200px
            }
        }
    </style>
</head>
<body>
<div class="app">
    <header>
        <h1>EEBUS Device Tester</h1>
        <div style="color:var(--muted);font-size:13px">Local web UI</div>
    </header>

    <div class="top">
        <div class="card panel" id="leftColumn">
            <section id="dataControlPanel" class="card" style="padding:12px">
                <h3 style="margin:0 0 6px 0">Data and Control</h3>

                <div style="display:flex;flex-direction:column;gap:8px">
                    <!-- LPC-->
                    <div style="font-weight:600">LPC</div>
                    <div id="lpcDisable" style="color:var(--muted);font-weight:600; display:flex;">not supported</div>
                    <div id="lpcDisplay" style="display:none;flex-direction:column;">
                        <h5>Scenario 1 - Control active power consumption</h5>
                        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Limit (W)</div>
                                <div id="lpcLimitValue" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Duration (s)</div>
                                <div id="lpcLimitDur" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Active</div>
                                <div id="lpcLimitActive" style="font-weight:600">-</div>
                            </div>
                        </div>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <input id="writeLimitValue" type="number" placeholder="value (W)" style="width:90px"
                                   value="3600"/>
                            <input id="writeLimitDurationSec" type="number" placeholder="duration (s)"
                                   style="width:90px" value="600"/>
                            <label style="display:flex;align-items:center;gap:6px;margin:0"><input id="writeLimitActive"
                                                                                                   type="checkbox"
                                                                                                   checked/>
                                Active</label>
                            <button id="sendWriteLimit">Send Loadcontrol Limit</button>
                        </div>
                        <h5>Scenario 2 - Failsafe</h5>
                        <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Failsafe Power (W)</div>
                                <div id="lpcFailsafePower" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Failsafe Duration (min)</div>
                                <div id="lpcFailsafeDuration" style="font-weight:600">-</div>
                            </div>
                        </div>
                        <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
                            <input id="writeFailsafePower" type="number" placeholder="failsafe power (W)"
                                   style="width:120px" value="2500"/>
                            <input id="writeFailsafeDurationMin" type="number" placeholder="duration (min)"
                                   style="width:120px" value="300"/>
                            <button id="sendWriteFailsafePower">Send Failsafe Power</button>
                            <button id="sendWriteFailsafeDuration">Send Failsafe Duration</button>
                        </div>
                    </div>

                    <div style="height:1px;background:grey;margin:6px 0"></div>
                    <!-- LPP-->
                    <div style="font-weight:600">LPP</div>
                    <div id="lppDisable" style="color:var(--muted);font-weight:600; display:flex;">not supported</div>
                    <div id="lppDisplay" style="display:none;gap:8px;flex-wrap:wrap;align-items:center">
                        <div style="min-width:110px">
                            <div style="font-size:12px;color:var(--muted)">Failsafe Value (W)</div>
                            <div id="lppFailsafeValue" style="font-weight:600">-</div>
                        </div>
                        <div style="min-width:110px">
                            <div style="font-size:12px;color:var(--muted)">Failsafe Dur (s)</div>
                            <div id="lppFailsafeDur" style="font-weight:600">-</div>
                        </div>
                        <div style="min-width:110px">
                            <div style="font-size:12px;color:var(--muted)">Limit (W)</div>
                            <div id="lppLimitValue" style="font-weight:600">-</div>
                        </div>
                        <div style="min-width:110px">
                            <div style="font-size:12px;color:var(--muted)">Limit Dur (s)</div>
                            <div id="lppLimitDur" style="font-weight:600">-</div>
                        </div>
                        <div style="min-width:80px">
                            <div style="font-size:12px;color:var(--muted)">Active</div>
                            <div id="lppLimitActive" style="font-weight:600">-</div>
                        </div>
                    </div>
                    <div style="height:1px;background:grey;margin:6px 0"></div>

                    <!-- EVSECC-->
                    <div style="font-weight:600">EVSECC</div>
                    <div id="evseccDisable" style="color:var(--muted);font-weight:600; display:flex;">not supported
                    </div>
                    <div id="evseccDisplay" style="display:none;gap:8px;flex-wrap:wrap;align-items:center">
                        <h5>Scenario 1 - EVSE sends manufacturer info</h5>
                        <div style="display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap; margin-top:8px;">
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Device Name</div>
                                <div id="evseccDeviceName" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Device Code</div>
                                <div id="evseccDevicecode" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Serial Number</div>
                                <div id="evseccSerialNumber" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Software Revision</div>
                                <div id="evseccSoftwareRevision" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Hardware Revision</div>
                                <div id="evseccHardwareRevision" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Vendor Name</div>
                                <div id="evseccVendorName" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Vendor Code</div>
                                <div id="evseccVendorCode" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Brand Name</div>
                                <div id="evseccBrandName" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Power Source</div>
                                <div id="evseccPowerSource" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Manufacturer Node ID</div>
                                <div id="evseccManufacturerNodeId" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Manufacturer Label</div>
                                <div id="evseccManufacturerLabel" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:80px">
                                <div style="font-size:12px;color:var(--muted)">Manufacturer Description</div>
                                <div id="evseccManufacturerDescription" style="font-weight:600">-</div>
                            </div>
                        </div>
                        <h5>Scenario 2 - EVSE sends error state</h5>
                        <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Operating State</div>
                                <div id="evseccOperatingState" style="font-weight:600">-</div>
                            </div>
                            <div style="min-width:110px">
                                <div style="font-size:12px;color:var(--muted)">Error Message</div>
                                <div id="evseccErrorMessage" style="font-weight:600">-</div>
                            </div>
                        </div>
                    </div>
                </div>

            </section>

            <section id="usecases" class="card" style="padding:12px">
                <h3 style="margin:0 0 6px 0">Usecases</h3>
                <div id="usecasesStatus" style="color:var(--muted);font-size:13px">Loading usecases...</div>
                <div id="usecaseList" style="margin-top:8px"></div>
            </section>

            <!-- Entities panel moved to left column under Usecases -->
            <section id="entitiesLeft" class="card" style="padding:12px">
                <h3 style="margin:0 0 6px 0">Entities</h3>
                <div id="entitiesStatus" style="color:var(--muted); font-size:13px; margin-bottom:6px">Loading
                    entities...
                </div>
                <ul id="entitiesList"></ul>
            </section>
        </div>

        <div id="splitter" class="splitter" title="Drag to resize"></div>
        <div class="card panel" id="parsedPanel"
             style="padding:12px; flex:1; min-width:200px; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 6px 0">SPINE Messages / Trace Log</h3>
            <div style="display:flex; gap:8px; margin-bottom:8px;">
                <button id="tabSpine" class="secondary">SPINE Messages</button>
                <button id="tabLog" class="secondary">Trace Log</button>
            </div>
            <div id="tabContent" style="display:flex; flex-direction:column; gap:8px; flex:1;">
                <div id="spineContent" style="display:block; flex:1; overflow:auto">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                        <div id="parsedTracesStatus" style="color:var(--muted); font-size:13px">Waiting for spine
                            messages...
                        </div>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <label style="font-size:13px;color:var(--muted);"><input id="eebusJsonCheckbox"
                                                                                     type="checkbox" checked
                                                                                     style="margin-right:6px;">EEBUS
                                Json Format</label>
                            <button id="clearParsed" class="secondary" type="button">Clear Parsed</button>
                        </div>
                    </div>
                    <ul id="parsedTracesList"></ul>

                    <div id="traceDetailPanel">
                        <div style="display:flex; align-items:center; gap:8px; justify-content:space-between;">
                            <div style="font-size:13px;color:var(--muted);">Click an entry to view the full JSON</div>
                            <button id="traceDetailClose" title="Close detail" style="display:none">✖</button>
                        </div>
                        <div id="traceDetail">Click an entry to view the full JSON.</div>
                    </div>
                </div>

                <div id="logContent" style="display:none; flex-direction:column; gap:8px;">
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <div style="color:var(--muted);">Trace Log (raw)</div>
                        <button id="logsToBottomBtn"
                                style="display:none; background:#2563eb; color:#fff; border:0; padding:6px 10px; border-radius:6px; cursor:pointer">
                            Scroll to bottom
                        </button>
                    </div>
                    <div id="logs"
                         style="white-space:pre-wrap; background:#0b1220; color:#dbeafe; padding:10px; height:240px; overflow:auto; border-radius:6px">
                        Connecting to log websocket...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- no footer -->
</div>

<script>
    // --- UI helpers ---
    function intInputSanitize(el) {
        if (!el) return;
        el.addEventListener('input', () => {
            // remove non-digit characters
            const v = el.value;
            const m = v.match(/^\d*/);
            if (m && m[0] !== v) el.value = m[0];
        });
    }

    // Setup elements safely
    const cmdSelect = document.getElementById('cmdSelect');

    // Usecases
    function renderUsecases(list) {
        const container = document.getElementById('usecaseList');
        if (!container) return;
        // dedupe by name
        const seen = new Set();
        container.innerHTML = '';
        if (!list || list.length === 0) {
            document.getElementById('usecasesStatus').textContent = 'No usecases available';
            return;
        }
        document.getElementById('usecasesStatus').textContent = '';
        list.forEach(u => {
            if (!u || !u.name) return;
            if (seen.has(u.name)) return;
            seen.add(u.name);
            setUsecase(u.name, u.supported);
        });
    }

    async function loadUsecases() {
        try {
            const res = await fetch('/api/usecases');
            if (!res.ok) {
                document.getElementById('usecasesStatus').textContent = 'Failed to load usecases';
                return;
            }
            const list = await res.json();
            renderUsecases(list);
        } catch (err) {
            document.getElementById('usecasesStatus').textContent = 'Error loading usecases: ' + err;
        }
    }

    function safeId(name) {
        const n = String(name || '').trim().toLowerCase();
        return 'uc-' + n.replace(/[^a-z0-9_-]/g, '_');
    }

    function setUsecase(name, supported) {
        const container = document.getElementById('usecaseList');
        if (!container) return;
        const id = safeId(name);
        // remove any existing elements with same id
        const existing = document.getElementById(id);
        if (existing) {
            const span = existing.querySelector('.state');
            if (span) {
                span.textContent = supported ? 'supported' : 'unsupported';
                span.className = 'state ' + (supported ? 'supported' : 'unsupported');
            }
            return;
        }
        // create new
        const div = document.createElement('div');
        div.className = 'usecase';
        div.id = id;
        const title = document.createElement('div');
        title.textContent = name;
        const state = document.createElement('div');
        state.className = 'state ' + (supported ? 'supported' : 'unsupported');
        state.textContent = supported ? 'supported' : 'unsupported';
        div.appendChild(title);
        div.appendChild(state);
        container.appendChild(div);
    }

    // --- Parsed trace handling helpers ---
    function extractTimestamp(line) {
        const ts = (typeof line === 'string') ? line.slice(0, 19) : '';
        if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(ts)) return ts;
        return ''
    }

    function extractDirection(line) {
        if (typeof line !== 'string') return '';
        const m = line.match(/TRACE\s*(Recv|Send)/i) || line.match(/Trace\s*(Recv|Send)/i);
        return m ? m[1].toLowerCase() : ''
    }

    function extractJsonString(line) {
        if (typeof line !== 'string') return null;
        const idx = line.indexOf('{');
        if (idx === -1) return null;
        return line.slice(idx)
    }

    function safeHasOwn(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key)
    }

    function findValueByKey(obj, key) {
        if (!obj || typeof obj !== 'object') return undefined;
        if (safeHasOwn(obj, key)) return obj[key];
        for (const k in obj) {
            if (!safeHasOwn(obj, k)) continue;
            const v = obj[k];
            if (typeof v === 'object') {
                const found = findValueByKey(v, key);
                if (found !== undefined) return found
            }
        }
        return undefined
    }

    function findCmdType(obj) {
        const cmd = findValueByKey(obj, 'cmd');
        if (!cmd) return '';

        function findObjInArray(a) {
            if (!Array.isArray(a)) return null;
            for (const item of a) {
                if (!item) continue;
                if (typeof item === 'object' && !Array.isArray(item)) {
                    for (const k in item) {
                        if (Object.prototype.hasOwnProperty.call(item, k)) return k
                    }
                }
                if (Array.isArray(item)) {
                    const deeper = findObjInArray(item);
                    if (deeper) return deeper
                }
            }
            return null
        }

        const t = findObjInArray(cmd);
        return t || ''
    }

    // parsed traces store
    const parsedTraces = [];
    let parsedIdCounter = 1;

    function addParsedTrace(entry) {
        entry.id = parsedIdCounter++;
        parsedTraces.unshift(entry);
        if (parsedTraces.length > 500) parsedTraces.pop();
        renderParsedTraces();
    }

    function clearParsedTraces() {
        parsedTraces.length = 0;
        renderParsedTraces();
        const detail = document.getElementById('traceDetail');
        if (detail) {
            detail.textContent = 'Click an entry to view the full JSON.';
            detail.style.display = 'none';
        }
        const btn = document.getElementById('traceDetailClose');
        if (btn) btn.style.display = 'none';
    }

    function renderParsedTraces() {
        const list = document.getElementById('parsedTracesList');
        if (!list) return;
        list.innerHTML = '';
        if (parsedTraces.length === 0) {
            document.getElementById('parsedTracesStatus').textContent = 'Waiting for traces...';
            return
        }
        document.getElementById('parsedTracesStatus').textContent = '';
        // only show up to 10 visible items but keep list scrollable
        parsedTraces.forEach(pt => {
            const li = document.createElement('li');
            li.id = 'pt-' + pt.id;
            const ts = document.createElement('div');
            ts.className = 'trace-ts';
            ts.textContent = pt.ts || '';
            const dir = document.createElement('div');
            dir.className = (pt.direction === 'recv' ? 'dir-recv' : 'dir-send');
            dir.textContent = (pt.direction || '').toUpperCase();
            const meta = document.createElement('div');
            meta.className = 'trace-meta';
            meta.innerHTML = '<span style="color:var(--muted)">cmdClassifier:</span> ' + (pt.cmdClassifier || '-') + ' &nbsp; <span style="color:var(--muted)">type:</span> ' + (pt.cmdType || '-');
            li.appendChild(ts);
            li.appendChild(dir);
            li.appendChild(meta);
            li.addEventListener('click', () => showTraceDetail(pt));
            list.appendChild(li);
        })
        // limit visible height to approx 10 items via CSS max-height on container; container already scrolls
    }

    /* --- Entities rendering (cascading list) --- */
    // remember expanded state across renders: key = entityAddress + '::' + featureIndex
    const expandedStates = {};

    function renderEntities(data) {
        const container = document.getElementById('entitiesList');
        if (!container) return;
        // preserve scroll and expanded state
        const prevScroll = container ? container.scrollTop : 0;
        const prevExpanded = Object.assign({}, expandedStates);
        container.innerHTML = '';
        if (!data || data.length === 0) {
            document.getElementById('entitiesStatus').textContent = 'No entities available';
            return;
        }
        document.getElementById('entitiesStatus').textContent = '';
        data.forEach((ent, entIndex) => {
            const li = document.createElement('li');
            const entKey = String(ent.address || '') || ('ent-' + entIndex);
            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            toggle.textContent = '+';
            const title = document.createElement('span');
            title.className = 'entity-addr';
            title.textContent = (ent.address || '') + ' ';
            const etype = document.createElement('span');
            etype.style.color = 'var(--muted)';
            etype.style.fontSize = '13px';
            etype.textContent = (ent.entityType ? ('[' + ent.entityType + ']') : '');
            li.appendChild(toggle);
            li.appendChild(title);
            li.appendChild(etype);

            const sub = document.createElement('div');
            sub.className = 'sub';
            sub.style.display = 'none';
            // features
            if (Array.isArray(ent.features)) {
                ent.features.forEach((f, featIndex) => {
                    const fdiv = document.createElement('div');
                    const fname = document.createElement('div');
                    fname.style.fontWeight = '600';
                    fname.textContent = (f.name || '');
                    const froles = document.createElement('div');
                    froles.style.color = 'var(--muted)';
                    froles.textContent = 'Roles: ' + (f.roles || '');
                    fdiv.appendChild(fname);
                    fdiv.appendChild(froles);
                    // operations
                    if (Array.isArray(f.operations) && f.operations.length > 0) {
                        const opl = document.createElement('ul');
                        opl.style.margin = '6px 0 8px 12px';
                        opl.style.padding = '0 0 0 14px';
                        opl.style.listStyle = 'disc';
                        f.operations.forEach(op => {
                            const oli = document.createElement('li');
                            const opKey = (op.op !== undefined && op.op !== null) ? String(op.op) : '';
                            const opName = (op.name !== undefined && op.name !== null) ? String(op.name) : '';
                            if (opKey && opName) {
                                oli.textContent = opKey + ' — ' + opName;
                            } else if (opName) {
                                oli.textContent = opName;
                            } else {
                                oli.textContent = opKey;
                            }
                            opl.appendChild(oli);
                        });
                        fdiv.appendChild(opl);
                    }
                    // restore expanded state for this feature
                    const featKey = entKey + '::' + String(featIndex);
                    if (prevExpanded[featKey]) {
                        fdiv.style.display = 'block';
                    }
                    sub.appendChild(fdiv);
                });
            }
            li.appendChild(sub);
            // restore toggled state if any feature is expanded
            const anyExpanded = Object.keys(prevExpanded).some(k => k.startsWith(entKey + '::'));
            if (anyExpanded) {
                sub.style.display = 'block';
                toggle.textContent = '−';
            }

            toggle.addEventListener('click', (e) => {
                const isOpen = sub.style.display !== 'none';
                if (isOpen) {
                    sub.style.display = 'none';
                    toggle.textContent = '+';
                    // clear expanded flags for this entity
                    Object.keys(expandedStates).forEach(k => {
                        if (k.startsWith(entKey + '::')) delete expandedStates[k];
                    });
                } else {
                    sub.style.display = 'block';
                    toggle.textContent = '−';
                    // mark all child features as expanded
                    const featCount = (Array.isArray(ent.features) ? ent.features.length : 0);
                    for (let i = 0; i < featCount; i++) {
                        expandedStates[entKey + '::' + i] = true;
                    }
                }
            });
            // clicking title toggles as well
            title.addEventListener('click', () => {
                toggle.click();
            });
            container.appendChild(li);
        });
        // restore scroll position
        try {
            container.scrollTop = prevScroll;
        } catch (e) {
        }
    }

    // load entities from API (initial)
    async function loadEntities() {
        try {
            const res = await fetch('/api/entities');
            if (!res.ok) {
                document.getElementById('entitiesStatus').textContent = 'Failed to load entities';
                return;
            }
            const data = await res.json();
            // server may respond with array or with {type:..., entities: [...]}
            let arr = [];
            if (Array.isArray(data)) arr = data;
            else if (data && Array.isArray(data.entities)) arr = data.entities;
            renderEntities(arr);
        } catch (e) {
            document.getElementById('entitiesStatus').textContent = 'Error loading entities: ' + e
        }
    }

    // --- Trace detail helpers ---
    function eebusJsonToJson(jsonStr) {
        if (typeof jsonStr !== 'string') jsonStr = String(jsonStr || '');
        try {
            let s = jsonStr;
            // Apply the simple transformations from the C++ routine
            s = s.replace(/\[\]/g, '{}');
            s = s.replace(/\}\]/g, '}');
            s = s.replace(/\},\{/g, ',');
            s = s.replace(/\[\{/g, '{');
            s = s.trim();

            // Try to parse the transformed string; if successful, pretty-print
            try {
                const parsed = JSON.parse(s);
                return JSON.stringify(parsed, null, 2);
            } catch (_) {
                // Fallback: simple pretty printer for single-line JSON-like strings
                return simplePretty(s);
            }
        } catch (e) {
            return jsonStr;
        }
    }

    function simplePretty(s) {
        // Basic character-wise pretty printer that inserts newlines and indentation
        let out = '';
        let indent = 0;
        const indentStr = () => '  '.repeat(indent);
        for (let i = 0; i < s.length; i++) {
            const ch = s[i];
            if (ch === '{' || ch === '[') {
                out += ch + '\n';
                indent++;
                out += indentStr();
            } else if (ch === '}' || ch === ']') {
                out += '\n';
                indent = Math.max(0, indent - 1);
                out += indentStr() + ch;
            } else if (ch === ',') {
                out += ch + '\n' + indentStr();
            } else {
                out += ch;
            }
        }
        return out;
    }

    let lastShownPT = null;

    function showTraceDetail(pt) {
        lastShownPT = pt;
        const detail = document.getElementById('traceDetail');
        try {
            const isRaw = document.getElementById('eebusJsonCheckbox') && document.getElementById('eebusJsonCheckbox').checked;
            let text = '';
            if (pt.rawJson) {
                // rawJson is an object; convert to string then optionally filter
                const s = JSON.stringify(pt.rawJson);
                text = isRaw ? JSON.stringify(pt.rawJson, null, 2) : eebusJsonToJson(s);
            } else {
                text = pt.rawLine || '';
            }
            detail.textContent = text;
        } catch (e) {
            detail.textContent = pt.rawLine || ''
        }
        detail.style.display = 'block';
        const closeBtn = document.getElementById('traceDetailClose');
        if (closeBtn) closeBtn.style.display = 'inline-block';
        detail.scrollTop = 0;
    }

    // Update displayed detail when checkbox changes
    const eebusCheckbox = document.getElementById('eebusJsonCheckbox');
    if (eebusCheckbox) {
        eebusCheckbox.addEventListener('change', () => {
            if (lastShownPT) showTraceDetail(lastShownPT);
        });
    }

    const traceDetailCloseBtn = document.getElementById('traceDetailClose');
    if (traceDetailCloseBtn) {
        traceDetailCloseBtn.addEventListener('click', function () {
            const detail = document.getElementById('traceDetail');
            if (detail) detail.style.display = 'none';
            this.style.display = 'none';
        });
    }

    const clearParsedBtn = document.getElementById('clearParsed');
    if (clearParsedBtn) {
        clearParsedBtn.addEventListener('click', clearParsedTraces);
    }

    // WebSocket for logs and usecase updates
    (function () {
        const logsEl = document.getElementById('logs');
        const logsBtn = document.getElementById('logsToBottomBtn');
        const protocol = (location.protocol === 'https:') ? 'wss:' : 'ws:';
        const wsUrl = protocol + '//' + location.host + '/ws/logs';
        let ws;
        // auto-scroll state: true means keep scrolling to newest messages
        let logsAutoScroll = true;

        function updateLogsButton() {
            if (!logsBtn) return;
            logsBtn.style.display = logsAutoScroll ? 'none' : 'inline-block';
        }

        // clicking the button forces scroll to bottom and re-enables auto-scroll
        if (logsBtn) {
            logsBtn.addEventListener('click', () => {
                logsAutoScroll = true;
                try {
                    logsEl.scrollTop = logsEl.scrollHeight;
                } catch (e) {
                }
                updateLogsButton();
            });
        }

        // detect user scroll - if user scrolls up, disable auto-scroll; if they scroll to bottom, enable it
        if (logsEl) {
            logsEl.addEventListener('scroll', () => {
                const atBottom = (logsEl.scrollHeight - logsEl.scrollTop - logsEl.clientHeight) <= 8;
                logsAutoScroll = atBottom;
                updateLogsButton();
            });
        }

        function connect() {
            ws = new WebSocket(wsUrl);
            ws.addEventListener('open', () => {
                if (logsEl) logsEl.textContent = ''
            });
            ws.addEventListener('message', (ev) => {
                const line = (typeof ev.data === 'string') ? ev.data : JSON.stringify(ev.data);
                // First try: is this a structured usecase JSON message we previously used?
                let parsed = null;
                try {
                    parsed = JSON.parse(line)
                } catch (e) {
                    parsed = null
                }
                if (parsed && parsed.type === 'usecase') {
                    const name = parsed.name;
                    const supported = !!parsed.supported;
                    setUsecase(name, supported);
                    return;
                }
                if (parsed && parsed.type === 'entities') {
                    const arr = parsed.entities || [];
                    renderEntities(arr);
                    return;
                }

                // Detect TRACE Send/Recv lines and try to parse JSON inside them
                const isTrace = (typeof line === 'string') && (/TRACE\s*(Recv|Send)/i.test(line) || /Trace\s*(Recv|Send)/i.test(line));
                if (isTrace) {
                    const ts = extractTimestamp(line);
                    const direction = extractDirection(line);
                    const js = extractJsonString(line);
                    if (js) {
                        try {
                            const obj = JSON.parse(js);
                            const cmdClassifier = findValueByKey(obj, 'cmdClassifier') || '';
                            const cmdType = findCmdType(obj) || '';
                            addParsedTrace({
                                ts: ts,
                                direction: direction,
                                cmdClassifier: cmdClassifier,
                                cmdType: cmdType,
                                rawJson: obj,
                                rawLine: line
                            });
                            return
                        } catch (e) { /* fallthrough to log */
                        }
                    }
                }

                // fallback: treat as plain log line
                if (logsEl) {
                    if (logsEl.textContent && logsEl.textContent.length > 0) {
                        logsEl.textContent += '\n' + line
                    } else {
                        logsEl.textContent = line
                    }
                }
                // only auto-scroll when enabled
                if (logsAutoScroll && logsEl) {
                    try {
                        logsEl.scrollTop = logsEl.scrollHeight;
                    } catch (e) {
                    }
                }
            });
            ws.addEventListener('close', () => {
                setTimeout(connect, 1000)
            });
            ws.addEventListener('error', (e) => {
                console.error('ws error', e);
                try {
                    ws.close()
                } catch (_) {
                }
            });
        }

        connect();
    })();

    // Build API payloads for new endpoints
    async function apiWrite(payload) {
        try {
            const res = await fetch('/api/write', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });
            const txt = await res.text();
            if (!res.ok) {
                alert('Write failed: ' + txt)
            }
        } catch (err) {
            alert('Request failed: ' + err)
        }
    }

    // wire up control buttons and polling of usecaseData
    document.addEventListener('DOMContentLoaded', () => {
        // sanitize duration inputs to integers where required
        intInputSanitize(document.getElementById('writeLimitDurationSec'));
        intInputSanitize(document.getElementById('writeFailsafeDurationMin'));

        const sendWriteLimitBtn = document.getElementById('sendWriteLimit');
        if (sendWriteLimitBtn) {
            sendWriteLimitBtn.addEventListener('click', () => {
                const val = parseFloat((document.getElementById('writeLimitValue') || {}).value) || 0;
                const dur = parseInt((document.getElementById('writeLimitDurationSec') || {}).value, 10) || 0;
                const active = !!(document.getElementById('writeLimitActive') && document.getElementById('writeLimitActive').checked);
                apiWrite({cmd: 'writeLPCConsumptionLimit', durationSeconds: dur, value: val, isActive: active});
            });
        }

        const sendFailsafePower = document.getElementById('sendWriteFailsafePower');
        if (sendFailsafePower) {
            sendFailsafePower.addEventListener('click', () => {
                const p = parseFloat((document.getElementById('writeFailsafePower') || {}).value) || 0;
                apiWrite({cmd: 'writeLPCFailsafeValue', failsafePower: p});
            });
        }

        const sendFailsafeDur = document.getElementById('sendWriteFailsafeDuration');
        if (sendFailsafeDur) {
            sendFailsafeDur.addEventListener('click', () => {
                const m = parseInt((document.getElementById('writeFailsafeDurationMin') || {}).value, 10) || 0;
                apiWrite({cmd: 'writeLPCFailsafeDuration', durationMinutes: m});
            });
        }

        // initial poll
        fetchUsecaseData();
        loadUsecases();
        loadEntities();

        // poll periodically for usecaseData so frontend shows latest values
        setInterval(fetchUsecaseData, 2000);
    });

    async function fetchUsecaseData() {
        try {
            const res = await fetch('/api/usecasedata');
            if (!res.ok) return;
            const d = await res.json();
            // update LPC
            const lpcVal = (d.lpcLimitValue !== undefined) ? d.lpcLimitValue : '-';
            document.getElementById('lpcLimitValue').textContent = lpcVal;
            document.getElementById('lpcLimitDur').textContent = (d.lpcLimitDurationSec !== undefined) ? d.lpcLimitDurationSec : '-';
            document.getElementById('lpcLimitActive').textContent = (d.lpcLimitActive !== undefined) ? (d.lpcLimitActive ? 'yes' : 'no') : '-';
            document.getElementById('failsafePower').textContent = (d.lpcFailsafePower !== undefined) ? d.lpcFailsafePower : '-';
            document.getElementById('failsafeDuration').textContent = (d.lpcFailsafeDurationMin !== undefined) ? d.lpcFailsafeDurationMin : '-';
            // update LPP explicit fields only when supported
            if (lppSupported) {
                const setText = (id, v) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = (v !== undefined ? v : '-');
                };
                setText('lppFailsafeValue', d.lppFailsafeValue);
                setText('lppFailsafeDur', d.lppFailsafeDurationSec);
                setText('lppLimitValue', d.lppLimitValue);
                setText('lppLimitDur', d.lppLimitDurationSec);
                setText('lppLimitActive', (d.lppLimitActive !== undefined) ? (d.lppLimitActive ? 'yes' : 'no') : '-');
            }
        } catch (e) {
            // ignore
        }
    }

    // Splitter resize logic
    ;(function () {
        const splitter = document.getElementById('splitter');
        const left = document.getElementById('leftColumn');
        if (!splitter || !left) return;
        let isDragging = false;
        let startX = 0;
        let startWidth = 0;
        const minW = 160;
        const maxW = 680;
        // restore stored width
        try {
            const w = localStorage.getItem('leftWidth');
            if (w) {
                left.style.width = w + 'px';
            }
        } catch (e) {
        }

        splitter.addEventListener('pointerdown', function (e) {
            isDragging = true;
            startX = e.clientX;
            startWidth = left.getBoundingClientRect().width;
            splitter.setPointerCapture(e.pointerId);
            document.body.style.userSelect = 'none';
            document.body.style.cursor = 'col-resize';
        });
        document.addEventListener('pointermove', function (e) {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            let nw = Math.round(startWidth + dx);
            if (nw < minW) nw = minW;
            if (nw > maxW) nw = maxW;
            left.style.width = nw + 'px';
        });

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            try {
                localStorage.setItem('leftWidth', String(left.getBoundingClientRect().width));
            } catch (_) {
            }
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
        }

        document.addEventListener('pointerup', endDrag);
        document.addEventListener('pointercancel', endDrag);
    })();

    // --- Tabs logic ---
    const tabSpine = document.getElementById('tabSpine');
    const tabLog = document.getElementById('tabLog');
    const spineContent = document.getElementById('spineContent');
    const logContent = document.getElementById('logContent');
    if (tabSpine && tabLog) {
        tabSpine.addEventListener('click', () => {
            if (spineContent) spineContent.style.display = 'block';
            if (logContent) logContent.style.display = 'none';
        });
        tabLog.addEventListener('click', () => {
            if (spineContent) spineContent.style.display = 'none';
            if (logContent) logContent.style.display = 'flex';
        });
    }

    // make sure logs element refers to the new location
    const logsEl = document.getElementById('logs') || document.querySelector('#logContent #logs');

    // add LPP support flag and helper to update LPP display based on support
    let lppSupported = false;

    function updateLPPDisplay(supported) {
        lppSupported = supported;
        const container = document.getElementById('lppDisplay');
        const disabledContainer = document.getElementById('lppDisable');
        if (supported) {
            container.style.display = 'flex';
            disabledContainer.style.display = 'none';
        } else {
            container.style.display = 'none';
            disabledContainer.style.display = 'flex';
        }
    }

    let lpcSupported = false;

    function updateLPCDisplay(supported) {
        lpcSupported = supported;
        const container = document.getElementById('lpcDisplay');
        const disabledContainer = document.getElementById('lpcDisable');
        if (supported) {
            container.style.display = 'flex';
            disabledContainer.style.display = 'none';
        } else {
            container.style.display = 'none';
            disabledContainer.style.display = 'flex';
        }
    }

    let evseccSupported = false;

    function updateEVSECCDisplay(supported) {
        evseccSupported = supported;
        const container = document.getElementById('evseccDisplay');
        const disabledContainer = document.getElementById('evseccDisable');
        if (supported) {
            container.style.display = 'flex';
            disabledContainer.style.display = 'none';
        } else {
            container.style.display = 'none';
            disabledContainer.style.display = 'flex';
        }
    }

    // ensure setUsecase notifies LPP state changes
    const originalSetUsecase = setUsecase;
    setUsecase = function (name, supported) {
        originalSetUsecase(name, supported);
        try {
            if (String(name || '').trim().toLowerCase() === 'lpp') {
                updateLPPDisplay(supported);
            } else if (String(name || '').trim().toLowerCase() === 'lpc') {
                updateLPCDisplay(supported);
            }
            else if (String(name || '').trim().toLowerCase() === 'evsecc') {
                updateEVSECCDisplay(supported);
            }
        } catch (e) {
        }
    }

    // initialize default (hidden) state until usecases loaded
    document.addEventListener('DOMContentLoaded', () => updateLPPDisplay(false));
    document.addEventListener('DOMContentLoaded', () => updateLPCDisplay(false));

    // adjust fetchUsecaseData to only update LPP fields when supported
    const originalFetchLPP = fetchUsecaseData;
    fetchUsecaseData = async function () {
        try {
            const res = await fetch('/api/usecasedata');
            if (!res.ok) return;
            const d = await res.json();

            const setText = (id, v) => {
                console.log('Updating %s to %s', id, v);
                const el = document.getElementById(id);
                if (el) el.textContent = (v !== undefined ? v : '-');
            };
            // update LPC
            if (lpcSupported) {
                setText('lpcLimitValue', d.lpcLimitValue);
                setText('lpcLimitDur', d.lpcLimitDurSeconds);
                setText('lpcLimitActive', d.lpcLimitActive);
                setText('lpcFailsafePower', d.lpcFailsafePower);
                setText('lpcFailsafeDuration', d.lpcFailsafeDurMinutes);
            }
            if (lppSupported) {
                // update LPP explicit fields only when supported
                setText('lppFailsafeValue', d.lppFailsafeValue);
                setText('lppFailsafeDur', d.lppFailsafeDurMinutes);
                setText('lppLimitValue', d.lppLimitValue);
                setText('lppLimitDur', d.lppLimitDurationSeconds);
                setText('lppLimitActive', (d.lppLimitActive !== undefined) ? (d.lppLimitActive ? 'yes' : 'no') : '-');
            }
            if(evseccSupported) {
                setText('evseccDeviceName', d.evseccDeviceName);
                setText('evseccDevicecode', d.evseccDeviceCode);
                setText('evseccSerialNumber', d.evseccSerialNumber);
                setText('evseccSoftwareRevision', d.evseccSoftwareRevision);
                setText('evseccHardwareRevision', d.evseccHardwareRevision);
                setText('evseccVendorName', d.evseccVendorName);
                setText('evseccVendorCode', d.evseccVendorCode);
                setText('evseccBrandName', d.evseccBrandName);
                setText('evseccPowerSource', d.evseccPowerSource);
                setText('evseccManufacturerNodeId', d.evseccManufacturerNodeIdentification);
                setText('evseccManufacturerLabel', d.evseccManufacturerLabel);
                setText('evseccManufacturerDescription', d.evseccManufacturerDescription);
                setText('evseccOperatingState', d.evseccOperatingState);
                setText('evseccErrorMessage', d.evseccOperatingStateDescription);

            }
        } catch (e) {
            // ignore
        }
    }
</script>
</body>
</html>
